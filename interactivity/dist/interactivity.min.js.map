{"version":3,"file":"interactivity.min.js","sources":["../node_modules/splaytree/dist/splay.esm.js","../node_modules/polygon-clipping/dist/polygon-clipping.esm.js"],"sourcesContent":["/**\n * splaytree v3.1.2\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar Node = /** @class */ (function () {\r\n    function Node(key, data) {\r\n        this.next = null;\r\n        this.key = key;\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n    return Node;\r\n}());\n\n/* follows \"An implementation of top-down splaying\"\r\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n */\r\nfunction DEFAULT_COMPARE(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n/**\r\n * Simple top down splay, not requiring i to be in the tree t.\r\n */\r\nfunction splay(i, t, comparator) {\r\n    var N = new Node(null, null);\r\n    var l = N;\r\n    var r = N;\r\n    while (true) {\r\n        var cmp = comparator(i, t.key);\r\n        //if (i < t.key) {\r\n        if (cmp < 0) {\r\n            if (t.left === null)\r\n                break;\r\n            //if (i < t.left.key) {\r\n            if (comparator(i, t.left.key) < 0) {\r\n                var y = t.left; /* rotate right */\r\n                t.left = y.right;\r\n                y.right = t;\r\n                t = y;\r\n                if (t.left === null)\r\n                    break;\r\n            }\r\n            r.left = t; /* link right */\r\n            r = t;\r\n            t = t.left;\r\n            //} else if (i > t.key) {\r\n        }\r\n        else if (cmp > 0) {\r\n            if (t.right === null)\r\n                break;\r\n            //if (i > t.right.key) {\r\n            if (comparator(i, t.right.key) > 0) {\r\n                var y = t.right; /* rotate left */\r\n                t.right = y.left;\r\n                y.left = t;\r\n                t = y;\r\n                if (t.right === null)\r\n                    break;\r\n            }\r\n            l.right = t; /* link left */\r\n            l = t;\r\n            t = t.right;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    /* assemble */\r\n    l.right = t.left;\r\n    r.left = t.right;\r\n    t.left = N.right;\r\n    t.right = N.left;\r\n    return t;\r\n}\r\nfunction insert(i, data, t, comparator) {\r\n    var node = new Node(i, data);\r\n    if (t === null) {\r\n        node.left = node.right = null;\r\n        return node;\r\n    }\r\n    t = splay(i, t, comparator);\r\n    var cmp = comparator(i, t.key);\r\n    if (cmp < 0) {\r\n        node.left = t.left;\r\n        node.right = t;\r\n        t.left = null;\r\n    }\r\n    else if (cmp >= 0) {\r\n        node.right = t.right;\r\n        node.left = t;\r\n        t.right = null;\r\n    }\r\n    return node;\r\n}\r\nfunction split(key, v, comparator) {\r\n    var left = null;\r\n    var right = null;\r\n    if (v) {\r\n        v = splay(key, v, comparator);\r\n        var cmp = comparator(v.key, key);\r\n        if (cmp === 0) {\r\n            left = v.left;\r\n            right = v.right;\r\n        }\r\n        else if (cmp < 0) {\r\n            right = v.right;\r\n            v.right = null;\r\n            left = v;\r\n        }\r\n        else {\r\n            left = v.left;\r\n            v.left = null;\r\n            right = v;\r\n        }\r\n    }\r\n    return { left: left, right: right };\r\n}\r\nfunction merge(left, right, comparator) {\r\n    if (right === null)\r\n        return left;\r\n    if (left === null)\r\n        return right;\r\n    right = splay(left.key, right, comparator);\r\n    right.left = left;\r\n    return right;\r\n}\r\n/**\r\n * Prints level of the tree\r\n */\r\nfunction printRow(root, prefix, isTail, out, printNode) {\r\n    if (root) {\r\n        out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\r\n        var indent = prefix + (isTail ? '    ' : '│   ');\r\n        if (root.left)\r\n            printRow(root.left, indent, false, out, printNode);\r\n        if (root.right)\r\n            printRow(root.right, indent, true, out, printNode);\r\n    }\r\n}\r\nvar Tree = /** @class */ (function () {\r\n    function Tree(comparator) {\r\n        if (comparator === void 0) { comparator = DEFAULT_COMPARE; }\r\n        this._root = null;\r\n        this._size = 0;\r\n        this._comparator = comparator;\r\n    }\r\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\r\n    Tree.prototype.insert = function (key, data) {\r\n        this._size++;\r\n        return this._root = insert(key, data, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\r\n    Tree.prototype.add = function (key, data) {\r\n        var node = new Node(key, data);\r\n        if (this._root === null) {\r\n            node.left = node.right = null;\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        var comparator = this._comparator;\r\n        var t = splay(key, this._root, comparator);\r\n        var cmp = comparator(key, t.key);\r\n        if (cmp === 0)\r\n            this._root = t;\r\n        else {\r\n            if (cmp < 0) {\r\n                node.left = t.left;\r\n                node.right = t;\r\n                t.left = null;\r\n            }\r\n            else if (cmp > 0) {\r\n                node.right = t.right;\r\n                node.left = t;\r\n                t.right = null;\r\n            }\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        return this._root;\r\n    };\r\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\r\n    Tree.prototype.remove = function (key) {\r\n        this._root = this._remove(key, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\r\n    Tree.prototype._remove = function (i, t, comparator) {\r\n        var x;\r\n        if (t === null)\r\n            return null;\r\n        t = splay(i, t, comparator);\r\n        var cmp = comparator(i, t.key);\r\n        if (cmp === 0) { /* found it */\r\n            if (t.left === null) {\r\n                x = t.right;\r\n            }\r\n            else {\r\n                x = splay(i, t.left, comparator);\r\n                x.right = t.right;\r\n            }\r\n            this._size--;\r\n            return x;\r\n        }\r\n        return t; /* It wasn't there */\r\n    };\r\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\r\n    Tree.prototype.pop = function () {\r\n        var node = this._root;\r\n        if (node) {\r\n            while (node.left)\r\n                node = node.left;\r\n            this._root = splay(node.key, this._root, this._comparator);\r\n            this._root = this._remove(node.key, this._root, this._comparator);\r\n            return { key: node.key, data: node.data };\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Find without splaying\r\n     */\r\n    Tree.prototype.findStatic = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return current;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.find = function (key) {\r\n        if (this._root) {\r\n            this._root = splay(key, this._root, this._comparator);\r\n            if (this._comparator(key, this._root.key) !== 0)\r\n                return null;\r\n        }\r\n        return this._root;\r\n    };\r\n    Tree.prototype.contains = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return true;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return false;\r\n    };\r\n    Tree.prototype.forEach = function (visitor, ctx) {\r\n        var current = this._root;\r\n        var Q = []; /* Initialize stack s */\r\n        var done = false;\r\n        while (!done) {\r\n            if (current !== null) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length !== 0) {\r\n                    current = Q.pop();\r\n                    visitor.call(ctx, current);\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\r\n    Tree.prototype.range = function (low, high, fn, ctx) {\r\n        var Q = [];\r\n        var compare = this._comparator;\r\n        var node = this._root;\r\n        var cmp;\r\n        while (Q.length !== 0 || node) {\r\n            if (node) {\r\n                Q.push(node);\r\n                node = node.left;\r\n            }\r\n            else {\r\n                node = Q.pop();\r\n                cmp = compare(node.key, high);\r\n                if (cmp > 0) {\r\n                    break;\r\n                }\r\n                else if (compare(node.key, low) >= 0) {\r\n                    if (fn.call(ctx, node))\r\n                        return this; // stop if smth is returned\r\n                }\r\n                node = node.right;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns array of keys\r\n     */\r\n    Tree.prototype.keys = function () {\r\n        var keys = [];\r\n        this.forEach(function (_a) {\r\n            var key = _a.key;\r\n            return keys.push(key);\r\n        });\r\n        return keys;\r\n    };\r\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\r\n    Tree.prototype.values = function () {\r\n        var values = [];\r\n        this.forEach(function (_a) {\r\n            var data = _a.data;\r\n            return values.push(data);\r\n        });\r\n        return values;\r\n    };\r\n    Tree.prototype.min = function () {\r\n        if (this._root)\r\n            return this.minNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.max = function () {\r\n        if (this._root)\r\n            return this.maxNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.minNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.left)\r\n                t = t.left;\r\n        return t;\r\n    };\r\n    Tree.prototype.maxNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.right)\r\n                t = t.right;\r\n        return t;\r\n    };\r\n    /**\r\n     * Returns node at given index\r\n     */\r\n    Tree.prototype.at = function (index) {\r\n        var current = this._root;\r\n        var done = false;\r\n        var i = 0;\r\n        var Q = [];\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = Q.pop();\r\n                    if (i === index)\r\n                        return current;\r\n                    i++;\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.next = function (d) {\r\n        var root = this._root;\r\n        var successor = null;\r\n        if (d.right) {\r\n            successor = d.right;\r\n            while (successor.left)\r\n                successor = successor.left;\r\n            return successor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0) {\r\n                successor = root;\r\n                root = root.left;\r\n            }\r\n            else\r\n                root = root.right;\r\n        }\r\n        return successor;\r\n    };\r\n    Tree.prototype.prev = function (d) {\r\n        var root = this._root;\r\n        var predecessor = null;\r\n        if (d.left !== null) {\r\n            predecessor = d.left;\r\n            while (predecessor.right)\r\n                predecessor = predecessor.right;\r\n            return predecessor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0)\r\n                root = root.left;\r\n            else {\r\n                predecessor = root;\r\n                root = root.right;\r\n            }\r\n        }\r\n        return predecessor;\r\n    };\r\n    Tree.prototype.clear = function () {\r\n        this._root = null;\r\n        this._size = 0;\r\n        return this;\r\n    };\r\n    Tree.prototype.toList = function () {\r\n        return toList(this._root);\r\n    };\r\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\r\n    Tree.prototype.load = function (keys, values, presort) {\r\n        if (values === void 0) { values = []; }\r\n        if (presort === void 0) { presort = false; }\r\n        var size = keys.length;\r\n        var comparator = this._comparator;\r\n        // sort if needed\r\n        if (presort)\r\n            sort(keys, values, 0, size - 1, comparator);\r\n        if (this._root === null) { // empty tree\r\n            this._root = loadRecursive(keys, values, 0, size);\r\n            this._size = size;\r\n        }\r\n        else { // that re-builds the whole tree from two in-order traversals\r\n            var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n            size = this._size + size;\r\n            this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n        }\r\n        return this;\r\n    };\r\n    Tree.prototype.isEmpty = function () { return this._root === null; };\r\n    Object.defineProperty(Tree.prototype, \"size\", {\r\n        get: function () { return this._size; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tree.prototype, \"root\", {\r\n        get: function () { return this._root; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Tree.prototype.toString = function (printNode) {\r\n        if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }\r\n        var out = [];\r\n        printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);\r\n        return out.join('');\r\n    };\r\n    Tree.prototype.update = function (key, newKey, newData) {\r\n        var comparator = this._comparator;\r\n        var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;\r\n        if (comparator(key, newKey) < 0) {\r\n            right = insert(newKey, newData, right, comparator);\r\n        }\r\n        else {\r\n            left = insert(newKey, newData, left, comparator);\r\n        }\r\n        this._root = merge(left, right, comparator);\r\n    };\r\n    Tree.prototype.split = function (key) {\r\n        return split(key, this._root, this._comparator);\r\n    };\r\n    Tree.prototype[Symbol.iterator] = function () {\r\n        var current, Q, done;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    current = this._root;\r\n                    Q = [];\r\n                    done = false;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!!done) return [3 /*break*/, 6];\r\n                    if (!(current !== null)) return [3 /*break*/, 2];\r\n                    Q.push(current);\r\n                    current = current.left;\r\n                    return [3 /*break*/, 5];\r\n                case 2:\r\n                    if (!(Q.length !== 0)) return [3 /*break*/, 4];\r\n                    current = Q.pop();\r\n                    return [4 /*yield*/, current];\r\n                case 3:\r\n                    _a.sent();\r\n                    current = current.right;\r\n                    return [3 /*break*/, 5];\r\n                case 4:\r\n                    done = true;\r\n                    _a.label = 5;\r\n                case 5: return [3 /*break*/, 1];\r\n                case 6: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return Tree;\r\n}());\r\nfunction loadRecursive(keys, values, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var key = keys[middle];\r\n        var data = values[middle];\r\n        var node = new Node(key, data);\r\n        node.left = loadRecursive(keys, values, start, middle);\r\n        node.right = loadRecursive(keys, values, middle + 1, end);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\nfunction createList(keys, values) {\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    for (var i = 0; i < keys.length; i++) {\r\n        p = p.next = new Node(keys[i], values[i]);\r\n    }\r\n    p.next = null;\r\n    return head.next;\r\n}\r\nfunction toList(root) {\r\n    var current = root;\r\n    var Q = [];\r\n    var done = false;\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    while (!done) {\r\n        if (current) {\r\n            Q.push(current);\r\n            current = current.left;\r\n        }\r\n        else {\r\n            if (Q.length > 0) {\r\n                current = p = p.next = Q.pop();\r\n                current = current.right;\r\n            }\r\n            else\r\n                done = true;\r\n        }\r\n    }\r\n    p.next = null; // that'll work even if the tree was empty\r\n    return head.next;\r\n}\r\nfunction sortedListToBST(list, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var left = sortedListToBST(list, start, middle);\r\n        var root = list.head;\r\n        root.left = left;\r\n        list.head = list.head.next;\r\n        root.right = sortedListToBST(list, middle + 1, end);\r\n        return root;\r\n    }\r\n    return null;\r\n}\r\nfunction mergeLists(l1, l2, compare) {\r\n    var head = new Node(null, null); // dummy\r\n    var p = head;\r\n    var p1 = l1;\r\n    var p2 = l2;\r\n    while (p1 !== null && p2 !== null) {\r\n        if (compare(p1.key, p2.key) < 0) {\r\n            p.next = p1;\r\n            p1 = p1.next;\r\n        }\r\n        else {\r\n            p.next = p2;\r\n            p2 = p2.next;\r\n        }\r\n        p = p.next;\r\n    }\r\n    if (p1 !== null) {\r\n        p.next = p1;\r\n    }\r\n    else if (p2 !== null) {\r\n        p.next = p2;\r\n    }\r\n    return head.next;\r\n}\r\nfunction sort(keys, values, left, right, compare) {\r\n    if (left >= right)\r\n        return;\r\n    var pivot = keys[(left + right) >> 1];\r\n    var i = left - 1;\r\n    var j = right + 1;\r\n    while (true) {\r\n        do\r\n            i++;\r\n        while (compare(keys[i], pivot) < 0);\r\n        do\r\n            j--;\r\n        while (compare(keys[j], pivot) > 0);\r\n        if (i >= j)\r\n            break;\r\n        var tmp = keys[i];\r\n        keys[i] = keys[j];\r\n        keys[j] = tmp;\r\n        tmp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = tmp;\r\n    }\r\n    sort(keys, values, left, j, compare);\r\n    sort(keys, values, j + 1, right, compare);\r\n}\n\nexport default Tree;\n//# sourceMappingURL=splay.esm.js.map\n","import SplayTree from 'splaytree';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\nvar isInBbox = function isInBbox(bbox, point) {\n  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\n\nvar getBboxOverlap = function getBboxOverlap(b1, b2) {\n  // check if the bboxes overlap at all\n  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n  var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n  var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n  return {\n    ll: {\n      x: lowerX,\n      y: lowerY\n    },\n    ur: {\n      x: upperX,\n      y: upperY\n    }\n  };\n};\n\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\nvar epsilon = Number.EPSILON; // IE Polyfill\n\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nvar EPSILON_SQ = epsilon * epsilon;\n/* FLP comparator */\n\nvar cmp = function cmp(a, b) {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  } // check if they're flp equal\n\n\n  var ab = a - b;\n\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0;\n  } // normal comparison\n\n\n  return a < b ? -1 : 1;\n};\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nvar PtRounder = /*#__PURE__*/function () {\n  function PtRounder() {\n    _classCallCheck(this, PtRounder);\n\n    this.reset();\n  }\n\n  _createClass(PtRounder, [{\n    key: \"reset\",\n    value: function reset() {\n      this.xRounder = new CoordRounder();\n      this.yRounder = new CoordRounder();\n    }\n  }, {\n    key: \"round\",\n    value: function round(x, y) {\n      return {\n        x: this.xRounder.round(x),\n        y: this.yRounder.round(y)\n      };\n    }\n  }]);\n\n  return PtRounder;\n}();\n\nvar CoordRounder = /*#__PURE__*/function () {\n  function CoordRounder() {\n    _classCallCheck(this, CoordRounder);\n\n    this.tree = new SplayTree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n    this.round(0);\n  } // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n\n\n  _createClass(CoordRounder, [{\n    key: \"round\",\n    value: function round(coord) {\n      var node = this.tree.add(coord);\n      var prevNode = this.tree.prev(node);\n\n      if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n        this.tree.remove(coord);\n        return prevNode.key;\n      }\n\n      var nextNode = this.tree.next(node);\n\n      if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n        this.tree.remove(coord);\n        return nextNode.key;\n      }\n\n      return coord;\n    }\n  }]);\n\n  return CoordRounder;\n}(); // singleton available by import\n\n\nvar rounder = new PtRounder();\n\n/* Cross Product of two vectors with first point at origin */\n\nvar crossProduct = function crossProduct(a, b) {\n  return a.x * b.y - a.y * b.x;\n};\n/* Dot Product of two vectors with first point at origin */\n\nvar dotProduct = function dotProduct(a, b) {\n  return a.x * b.x + a.y * b.y;\n};\n/* Comparator for two vectors with same starting point */\n\nvar compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n  var v1 = {\n    x: endPt1.x - basePt.x,\n    y: endPt1.y - basePt.y\n  };\n  var v2 = {\n    x: endPt2.x - basePt.x,\n    y: endPt2.y - basePt.y\n  };\n  var kross = crossProduct(v1, v2);\n  return cmp(kross, 0);\n};\nvar length = function length(v) {\n  return Math.sqrt(dotProduct(v, v));\n};\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar horizontalIntersection = function horizontalIntersection(pt, v, y) {\n  if (v.y === 0) return null;\n  return {\n    x: pt.x + v.x / v.y * (y - pt.y),\n    y: y\n  };\n};\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar verticalIntersection = function verticalIntersection(pt, v, x) {\n  if (v.x === 0) return null;\n  return {\n    x: x,\n    y: pt.y + v.y / v.x * (x - pt.x)\n  };\n};\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar intersection = function intersection(pt1, v1, pt2, v2) {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  var kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n  var ve = {\n    x: pt2.x - pt1.x,\n    y: pt2.y - pt1.y\n  };\n  var d1 = crossProduct(ve, v1) / kross;\n  var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n  var x1 = pt1.x + d2 * v1.x,\n      x2 = pt2.x + d1 * v2.x;\n  var y1 = pt1.y + d2 * v1.y,\n      y2 = pt2.y + d1 * v2.y;\n  var x = (x1 + x2) / 2;\n  var y = (y1 + y2) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar SweepEvent = /*#__PURE__*/function () {\n  _createClass(SweepEvent, null, [{\n    key: \"compare\",\n    // for ordering sweep events in the sweep event queue\n    value: function compare(a, b) {\n      // favor event with a point that the sweep line hits first\n      var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n      if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n      if (a.point !== b.point) a.link(b); // favor right events over left\n\n      if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n      // ordering of this case is the same as for their segments\n\n      return Segment.compare(a.segment, b.segment);\n    } // for ordering points in sweep line order\n\n  }, {\n    key: \"comparePoints\",\n    value: function comparePoints(aPt, bPt) {\n      if (aPt.x < bPt.x) return -1;\n      if (aPt.x > bPt.x) return 1;\n      if (aPt.y < bPt.y) return -1;\n      if (aPt.y > bPt.y) return 1;\n      return 0;\n    } // Warning: 'point' input will be modified and re-used (for performance)\n\n  }]);\n\n  function SweepEvent(point, isLeft) {\n    _classCallCheck(this, SweepEvent);\n\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n  }\n\n  _createClass(SweepEvent, [{\n    key: \"link\",\n    value: function link(other) {\n      if (other.point === this.point) {\n        throw new Error('Tried to link already linked events');\n      }\n\n      var otherEvents = other.point.events;\n\n      for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n        var evt = otherEvents[i];\n        this.point.events.push(evt);\n        evt.point = this.point;\n      }\n\n      this.checkForConsuming();\n    }\n    /* Do a pass over our linked events and check to see if any pair\n     * of segments match, and should be consumed. */\n\n  }, {\n    key: \"checkForConsuming\",\n    value: function checkForConsuming() {\n      // FIXME: The loops in this method run O(n^2) => no good.\n      //        Maintain little ordered sweep event trees?\n      //        Can we maintaining an ordering that avoids the need\n      //        for the re-sorting with getLeftmostComparator in geom-out?\n      // Compare each pair of events to see if other events also match\n      var numEvents = this.point.events.length;\n\n      for (var i = 0; i < numEvents; i++) {\n        var evt1 = this.point.events[i];\n        if (evt1.segment.consumedBy !== undefined) continue;\n\n        for (var j = i + 1; j < numEvents; j++) {\n          var evt2 = this.point.events[j];\n          if (evt2.consumedBy !== undefined) continue;\n          if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n          evt1.segment.consume(evt2.segment);\n        }\n      }\n    }\n  }, {\n    key: \"getAvailableLinkedEvents\",\n    value: function getAvailableLinkedEvents() {\n      // point.events is always of length 2 or greater\n      var events = [];\n\n      for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n        var evt = this.point.events[i];\n\n        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n          events.push(evt);\n        }\n      }\n\n      return events;\n    }\n    /**\n     * Returns a comparator function for sorting linked events that will\n     * favor the event that will give us the smallest left-side angle.\n     * All ring construction starts as low as possible heading to the right,\n     * so by always turning left as sharp as possible we'll get polygons\n     * without uncessary loops & holes.\n     *\n     * The comparator function has a compute cache such that it avoids\n     * re-computing already-computed values.\n     */\n\n  }, {\n    key: \"getLeftmostComparator\",\n    value: function getLeftmostComparator(baseEvent) {\n      var _this = this;\n\n      var cache = new Map();\n\n      var fillCache = function fillCache(linkedEvent) {\n        var nextEvent = linkedEvent.otherSE;\n        cache.set(linkedEvent, {\n          sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n          cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n        });\n      };\n\n      return function (a, b) {\n        if (!cache.has(a)) fillCache(a);\n        if (!cache.has(b)) fillCache(b);\n\n        var _cache$get = cache.get(a),\n            asine = _cache$get.sine,\n            acosine = _cache$get.cosine;\n\n        var _cache$get2 = cache.get(b),\n            bsine = _cache$get2.sine,\n            bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n        if (asine >= 0 && bsine >= 0) {\n          if (acosine < bcosine) return 1;\n          if (acosine > bcosine) return -1;\n          return 0;\n        } // both below x-axis\n\n\n        if (asine < 0 && bsine < 0) {\n          if (acosine < bcosine) return -1;\n          if (acosine > bcosine) return 1;\n          return 0;\n        } // one above x-axis, one below\n\n\n        if (bsine < asine) return -1;\n        if (bsine > asine) return 1;\n        return 0;\n      };\n    }\n  }]);\n\n  return SweepEvent;\n}();\n\n// segments and sweep events when all else is identical\n\nvar segmentId = 0;\n\nvar Segment = /*#__PURE__*/function () {\n  _createClass(Segment, null, [{\n    key: \"compare\",\n\n    /* This compare() function is for ordering segments in the sweep\n     * line tree, and does so according to the following criteria:\n     *\n     * Consider the vertical line that lies an infinestimal step to the\n     * right of the right-more of the two left endpoints of the input\n     * segments. Imagine slowly moving a point up from negative infinity\n     * in the increasing y direction. Which of the two segments will that\n     * point intersect first? That segment comes 'before' the other one.\n     *\n     * If neither segment would be intersected by such a line, (if one\n     * or more of the segments are vertical) then the line to be considered\n     * is directly on the right-more of the two left inputs.\n     */\n    value: function compare(a, b) {\n      var alx = a.leftSE.point.x;\n      var blx = b.leftSE.point.x;\n      var arx = a.rightSE.point.x;\n      var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n      if (brx < alx) return 1;\n      if (arx < blx) return -1;\n      var aly = a.leftSE.point.y;\n      var bly = b.leftSE.point.y;\n      var ary = a.rightSE.point.y;\n      var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n      if (alx < blx) {\n        // are the two segments in the same horizontal plane?\n        if (bly < aly && bly < ary) return 1;\n        if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n        var aCmpBLeft = a.comparePoint(b.leftSE.point);\n        if (aCmpBLeft < 0) return 1;\n        if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n        var bCmpARight = b.comparePoint(a.rightSE.point);\n        if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return -1;\n      } // is left endpoint of segment A the right-more?\n\n\n      if (alx > blx) {\n        if (aly < bly && aly < bry) return -1;\n        if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n        var bCmpALeft = b.comparePoint(a.leftSE.point);\n        if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n        var aCmpBRight = a.comparePoint(b.rightSE.point);\n        if (aCmpBRight < 0) return 1;\n        if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return 1;\n      } // if we get here, the two left endpoints are in the same\n      // vertical plane, ie alx === blx\n      // consider the lower left-endpoint to come first\n\n\n      if (aly < bly) return -1;\n      if (aly > bly) return 1; // left endpoints are identical\n      // check for colinearity by using the left-more right endpoint\n      // is the A right endpoint more left-more?\n\n      if (arx < brx) {\n        var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n        if (_bCmpARight !== 0) return _bCmpARight;\n      } // is the B right endpoint more left-more?\n\n\n      if (arx > brx) {\n        var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n        if (_aCmpBRight < 0) return 1;\n        if (_aCmpBRight > 0) return -1;\n      }\n\n      if (arx !== brx) {\n        // are these two [almost] vertical segments with opposite orientation?\n        // if so, the one with the lower right endpoint comes first\n        var ay = ary - aly;\n        var ax = arx - alx;\n        var by = bry - bly;\n        var bx = brx - blx;\n        if (ay > ax && by < bx) return 1;\n        if (ay < ax && by > bx) return -1;\n      } // we have colinear segments with matching orientation\n      // consider the one with more left-more right endpoint to be first\n\n\n      if (arx > brx) return 1;\n      if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n      // vertical plane, ie arx === brx\n      // consider the lower right-endpoint to come first\n\n      if (ary < bry) return -1;\n      if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n      // fall back on creation order as consistent tie-breaker\n\n      if (a.id < b.id) return -1;\n      if (a.id > b.id) return 1; // identical segment, ie a === b\n\n      return 0;\n    }\n    /* Warning: a reference to ringWindings input will be stored,\n     *  and possibly will be later modified */\n\n  }]);\n\n  function Segment(leftSE, rightSE, rings, windings) {\n    _classCallCheck(this, Segment);\n\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings; // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  _createClass(Segment, [{\n    key: \"replaceRightSE\",\n\n    /* When a segment is split, the rightSE is replaced with a new sweep event */\n    value: function replaceRightSE(newRightSE) {\n      this.rightSE = newRightSE;\n      this.rightSE.segment = this;\n      this.rightSE.otherSE = this.leftSE;\n      this.leftSE.otherSE = this.rightSE;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var y1 = this.leftSE.point.y;\n      var y2 = this.rightSE.point.y;\n      return {\n        ll: {\n          x: this.leftSE.point.x,\n          y: y1 < y2 ? y1 : y2\n        },\n        ur: {\n          x: this.rightSE.point.x,\n          y: y1 > y2 ? y1 : y2\n        }\n      };\n    }\n    /* A vector from the left point to the right */\n\n  }, {\n    key: \"vector\",\n    value: function vector() {\n      return {\n        x: this.rightSE.point.x - this.leftSE.point.x,\n        y: this.rightSE.point.y - this.leftSE.point.y\n      };\n    }\n  }, {\n    key: \"isAnEndpoint\",\n    value: function isAnEndpoint(pt) {\n      return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n    }\n    /* Compare this segment with a point.\n     *\n     * A point P is considered to be colinear to a segment if there\n     * exists a distance D such that if we travel along the segment\n     * from one * endpoint towards the other a distance D, we find\n     * ourselves at point P.\n     *\n     * Return value indicates:\n     *\n     *   1: point lies above the segment (to the left of vertical)\n     *   0: point is colinear to segment\n     *  -1: point lies below the segment (to the right of vertical)\n     */\n\n  }, {\n    key: \"comparePoint\",\n    value: function comparePoint(point) {\n      if (this.isAnEndpoint(point)) return 0;\n      var lPt = this.leftSE.point;\n      var rPt = this.rightSE.point;\n      var v = this.vector(); // Exactly vertical segments.\n\n      if (lPt.x === rPt.x) {\n        if (point.x === lPt.x) return 0;\n        return point.x < lPt.x ? 1 : -1;\n      } // Nearly vertical segments with an intersection.\n      // Check to see where a point on the line with matching Y coordinate is.\n\n\n      var yDist = (point.y - lPt.y) / v.y;\n      var xFromYDist = lPt.x + yDist * v.x;\n      if (point.x === xFromYDist) return 0; // General case.\n      // Check to see where a point on the line with matching X coordinate is.\n\n      var xDist = (point.x - lPt.x) / v.x;\n      var yFromXDist = lPt.y + xDist * v.y;\n      if (point.y === yFromXDist) return 0;\n      return point.y < yFromXDist ? -1 : 1;\n    }\n    /**\n     * Given another segment, returns the first non-trivial intersection\n     * between the two segments (in terms of sweep line ordering), if it exists.\n     *\n     * A 'non-trivial' intersection is one that will cause one or both of the\n     * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n     *\n     *   * endpoint of segA with endpoint of segB --> trivial\n     *   * endpoint of segA with point along segB --> non-trivial\n     *   * endpoint of segB with point along segA --> non-trivial\n     *   * point along segA with point along segB --> non-trivial\n     *\n     * If no non-trivial intersection exists, return null\n     * Else, return null.\n     */\n\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(other) {\n      // If bboxes don't overlap, there can't be any intersections\n      var tBbox = this.bbox();\n      var oBbox = other.bbox();\n      var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n      if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n      // This will 'snap' intersections to endpoints if possible, and will\n      // handle cases of colinearity.\n\n      var tlp = this.leftSE.point;\n      var trp = this.rightSE.point;\n      var olp = other.leftSE.point;\n      var orp = other.rightSE.point; // does each endpoint touch the other segment?\n      // note that we restrict the 'touching' definition to only allow segments\n      // to touch endpoints that lie forward from where we are in the sweep line pass\n\n      var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n      var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n      var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n      var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n      if (touchesThisLSE && touchesOtherLSE) {\n        // these two cases are for colinear segments with matching left\n        // endpoints, and one segment being longer than the other\n        if (touchesThisRSE && !touchesOtherRSE) return trp;\n        if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n        // or just on their left endpoint (one trivial intersection\n\n        return null;\n      } // does this left endpoint matches (other doesn't)\n\n\n      if (touchesThisLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesOtherRSE) {\n          if (tlp.x === orp.x && tlp.y === orp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return tlp;\n      } // does other left endpoint matches (this doesn't)\n\n\n      if (touchesOtherLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesThisRSE) {\n          if (trp.x === olp.x && trp.y === olp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return olp;\n      } // trivial intersection on right endpoints\n\n\n      if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n      if (touchesThisRSE) return trp;\n      if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n      // infinite lines laid over the segments\n\n      var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n      // they would have an endpoint intersection and that case was already handled above\n\n      if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n      if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n      return rounder.round(pt.x, pt.y);\n    }\n    /**\n     * Split the given segment into multiple segments on the given points.\n     *  * Each existing segment will retain its leftSE and a new rightSE will be\n     *    generated for it.\n     *  * A new segment will be generated which will adopt the original segment's\n     *    rightSE, and a new leftSE will be generated for it.\n     *  * If there are more than two points given to split on, new segments\n     *    in the middle will be generated with new leftSE and rightSE's.\n     *  * An array of the newly generated SweepEvents will be returned.\n     *\n     * Warning: input array of points is modified\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(point) {\n      var newEvents = [];\n      var alreadyLinked = point.events !== undefined;\n      var newLeftSE = new SweepEvent(point, true);\n      var newRightSE = new SweepEvent(point, false);\n      var oldRightSE = this.rightSE;\n      this.replaceRightSE(newRightSE);\n      newEvents.push(newRightSE);\n      newEvents.push(newLeftSE);\n      var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n      // sometimes one of the resulting new segments is vertical, in which\n      // case its left and right events may need to be swapped\n\n      if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n        newSeg.swapEvents();\n      }\n\n      if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n        this.swapEvents();\n      } // in the point we just used to create new sweep events with was already\n      // linked to other events, we need to check if either of the affected\n      // segments should be consumed\n\n\n      if (alreadyLinked) {\n        newLeftSE.checkForConsuming();\n        newRightSE.checkForConsuming();\n      }\n\n      return newEvents;\n    }\n    /* Swap which event is left and right */\n\n  }, {\n    key: \"swapEvents\",\n    value: function swapEvents() {\n      var tmpEvt = this.rightSE;\n      this.rightSE = this.leftSE;\n      this.leftSE = tmpEvt;\n      this.leftSE.isLeft = true;\n      this.rightSE.isLeft = false;\n\n      for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n        this.windings[i] *= -1;\n      }\n    }\n    /* Consume another segment. We take their rings under our wing\n     * and mark them as consumed. Use for perfectly overlapping segments */\n\n  }, {\n    key: \"consume\",\n    value: function consume(other) {\n      var consumer = this;\n      var consumee = other;\n\n      while (consumer.consumedBy) {\n        consumer = consumer.consumedBy;\n      }\n\n      while (consumee.consumedBy) {\n        consumee = consumee.consumedBy;\n      }\n\n      var cmp = Segment.compare(consumer, consumee);\n      if (cmp === 0) return; // already consumed\n      // the winner of the consumption is the earlier segment\n      // according to sweep line ordering\n\n      if (cmp > 0) {\n        var tmp = consumer;\n        consumer = consumee;\n        consumee = tmp;\n      } // make sure a segment doesn't consume it's prev\n\n\n      if (consumer.prev === consumee) {\n        var _tmp = consumer;\n        consumer = consumee;\n        consumee = _tmp;\n      }\n\n      for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n        var ring = consumee.rings[i];\n        var winding = consumee.windings[i];\n        var index = consumer.rings.indexOf(ring);\n\n        if (index === -1) {\n          consumer.rings.push(ring);\n          consumer.windings.push(winding);\n        } else consumer.windings[index] += winding;\n      }\n\n      consumee.rings = null;\n      consumee.windings = null;\n      consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n      consumee.leftSE.consumedBy = consumer.leftSE;\n      consumee.rightSE.consumedBy = consumer.rightSE;\n    }\n    /* The first segment previous segment chain that is in the result */\n\n  }, {\n    key: \"prevInResult\",\n    value: function prevInResult() {\n      if (this._prevInResult !== undefined) return this._prevInResult;\n      if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n      return this._prevInResult;\n    }\n  }, {\n    key: \"beforeState\",\n    value: function beforeState() {\n      if (this._beforeState !== undefined) return this._beforeState;\n      if (!this.prev) this._beforeState = {\n        rings: [],\n        windings: [],\n        multiPolys: []\n      };else {\n        var seg = this.prev.consumedBy || this.prev;\n        this._beforeState = seg.afterState();\n      }\n      return this._beforeState;\n    }\n  }, {\n    key: \"afterState\",\n    value: function afterState() {\n      if (this._afterState !== undefined) return this._afterState;\n      var beforeState = this.beforeState();\n      this._afterState = {\n        rings: beforeState.rings.slice(0),\n        windings: beforeState.windings.slice(0),\n        multiPolys: []\n      };\n      var ringsAfter = this._afterState.rings;\n      var windingsAfter = this._afterState.windings;\n      var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n      for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n        var ring = this.rings[i];\n        var winding = this.windings[i];\n        var index = ringsAfter.indexOf(ring);\n\n        if (index === -1) {\n          ringsAfter.push(ring);\n          windingsAfter.push(winding);\n        } else windingsAfter[index] += winding;\n      } // calcualte polysAfter\n\n\n      var polysAfter = [];\n      var polysExclude = [];\n\n      for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n        if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n        var _ring = ringsAfter[_i];\n        var poly = _ring.poly;\n        if (polysExclude.indexOf(poly) !== -1) continue;\n        if (_ring.isExterior) polysAfter.push(poly);else {\n          if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n          var _index = polysAfter.indexOf(_ring.poly);\n\n          if (_index !== -1) polysAfter.splice(_index, 1);\n        }\n      } // calculate multiPolysAfter\n\n\n      for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n        var mp = polysAfter[_i2].multiPoly;\n        if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n      }\n\n      return this._afterState;\n    }\n    /* Is this segment part of the final result? */\n\n  }, {\n    key: \"isInResult\",\n    value: function isInResult() {\n      // if we've been consumed, we're not in the result\n      if (this.consumedBy) return false;\n      if (this._isInResult !== undefined) return this._isInResult;\n      var mpsBefore = this.beforeState().multiPolys;\n      var mpsAfter = this.afterState().multiPolys;\n\n      switch (operation.type) {\n        case 'union':\n          {\n            // UNION - included iff:\n            //  * On one side of us there is 0 poly interiors AND\n            //  * On the other side there is 1 or more.\n            var noBefores = mpsBefore.length === 0;\n            var noAfters = mpsAfter.length === 0;\n            this._isInResult = noBefores !== noAfters;\n            break;\n          }\n\n        case 'intersection':\n          {\n            // INTERSECTION - included iff:\n            //  * on one side of us all multipolys are rep. with poly interiors AND\n            //  * on the other side of us, not all multipolys are repsented\n            //    with poly interiors\n            var least;\n            var most;\n\n            if (mpsBefore.length < mpsAfter.length) {\n              least = mpsBefore.length;\n              most = mpsAfter.length;\n            } else {\n              least = mpsAfter.length;\n              most = mpsBefore.length;\n            }\n\n            this._isInResult = most === operation.numMultiPolys && least < most;\n            break;\n          }\n\n        case 'xor':\n          {\n            // XOR - included iff:\n            //  * the difference between the number of multipolys represented\n            //    with poly interiors on our two sides is an odd number\n            var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n            this._isInResult = diff % 2 === 1;\n            break;\n          }\n\n        case 'difference':\n          {\n            // DIFFERENCE included iff:\n            //  * on exactly one side, we have just the subject\n            var isJustSubject = function isJustSubject(mps) {\n              return mps.length === 1 && mps[0].isSubject;\n            };\n\n            this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n            break;\n          }\n\n        default:\n          throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n      }\n\n      return this._isInResult;\n    }\n  }], [{\n    key: \"fromRing\",\n    value: function fromRing(pt1, pt2, ring) {\n      var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n      var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n      if (cmpPts < 0) {\n        leftPt = pt1;\n        rightPt = pt2;\n        winding = 1;\n      } else if (cmpPts > 0) {\n        leftPt = pt2;\n        rightPt = pt1;\n        winding = -1;\n      } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n      var leftSE = new SweepEvent(leftPt, true);\n      var rightSE = new SweepEvent(rightPt, false);\n      return new Segment(leftSE, rightSE, [ring], [winding]);\n    }\n  }]);\n\n  return Segment;\n}();\n\nvar RingIn = /*#__PURE__*/function () {\n  function RingIn(geomRing, poly, isExterior) {\n    _classCallCheck(this, RingIn);\n\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n\n    if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n    this.bbox = {\n      ll: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      },\n      ur: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      }\n    };\n    var prevPoint = firstPoint;\n\n    for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    } // add segment from last to first if last is not the same as first\n\n\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n\n  _createClass(RingIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n        var segment = this.segments[i];\n        sweepEvents.push(segment.leftSE);\n        sweepEvents.push(segment.rightSE);\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return RingIn;\n}();\nvar PolyIn = /*#__PURE__*/function () {\n  function PolyIn(geomPoly, multiPoly) {\n    _classCallCheck(this, PolyIn);\n\n    if (!Array.isArray(geomPoly)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n    this.bbox = {\n      ll: {\n        x: this.exteriorRing.bbox.ll.x,\n        y: this.exteriorRing.bbox.ll.y\n      },\n      ur: {\n        x: this.exteriorRing.bbox.ur.x,\n        y: this.exteriorRing.bbox.ur.y\n      }\n    };\n    this.interiorRings = [];\n\n    for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      var ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n\n    this.multiPoly = multiPoly;\n  }\n\n  _createClass(PolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = this.exteriorRing.getSweepEvents();\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n        for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(ringSweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return PolyIn;\n}();\nvar MultiPolyIn = /*#__PURE__*/function () {\n  function MultiPolyIn(geom, isSubject) {\n    _classCallCheck(this, MultiPolyIn);\n\n    if (!Array.isArray(geom)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === 'number') geom = [geom];\n    } catch (ex) {// The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n\n    this.polys = [];\n    this.bbox = {\n      ll: {\n        x: Number.POSITIVE_INFINITY,\n        y: Number.POSITIVE_INFINITY\n      },\n      ur: {\n        x: Number.NEGATIVE_INFINITY,\n        y: Number.NEGATIVE_INFINITY\n      }\n    };\n\n    for (var i = 0, iMax = geom.length; i < iMax; i++) {\n      var poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n\n    this.isSubject = isSubject;\n  }\n\n  _createClass(MultiPolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polySweepEvents = this.polys[i].getSweepEvents();\n\n        for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(polySweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return MultiPolyIn;\n}();\n\nvar RingOut = /*#__PURE__*/function () {\n  _createClass(RingOut, null, [{\n    key: \"factory\",\n\n    /* Given the segments from the sweep line pass, compute & return a series\n     * of closed rings from all the segments marked to be part of the result */\n    value: function factory(allSegments) {\n      var ringsOut = [];\n\n      for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n        var segment = allSegments[i];\n        if (!segment.isInResult() || segment.ringOut) continue;\n        var prevEvent = null;\n        var event = segment.leftSE;\n        var nextEvent = segment.rightSE;\n        var events = [event];\n        var startingPoint = event.point;\n        var intersectionLEs = [];\n        /* Walk the chain of linked events to form a closed ring */\n\n        while (true) {\n          prevEvent = event;\n          event = nextEvent;\n          events.push(event);\n          /* Is the ring complete? */\n\n          if (event.point === startingPoint) break;\n\n          while (true) {\n            var availableLEs = event.getAvailableLinkedEvents();\n            /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n             * part of the algorithm malfunctioned... please file a bug report. */\n\n            if (availableLEs.length === 0) {\n              var firstPt = events[0].point;\n              var lastPt = events[events.length - 1].point;\n              throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n            }\n            /* Only one way to go, so cotinue on the path */\n\n\n            if (availableLEs.length === 1) {\n              nextEvent = availableLEs[0].otherSE;\n              break;\n            }\n            /* We must have an intersection. Check for a completed loop */\n\n\n            var indexLE = null;\n\n            for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n              if (intersectionLEs[j].point === event.point) {\n                indexLE = j;\n                break;\n              }\n            }\n            /* Found a completed loop. Cut that off and make a ring */\n\n\n            if (indexLE !== null) {\n              var intersectionLE = intersectionLEs.splice(indexLE)[0];\n              var ringEvents = events.splice(intersectionLE.index);\n              ringEvents.unshift(ringEvents[0].otherSE);\n              ringsOut.push(new RingOut(ringEvents.reverse()));\n              continue;\n            }\n            /* register the intersection */\n\n\n            intersectionLEs.push({\n              index: events.length,\n              point: event.point\n            });\n            /* Choose the left-most option to continue the walk */\n\n            var comparator = event.getLeftmostComparator(prevEvent);\n            nextEvent = availableLEs.sort(comparator)[0].otherSE;\n            break;\n          }\n        }\n\n        ringsOut.push(new RingOut(events));\n      }\n\n      return ringsOut;\n    }\n  }]);\n\n  function RingOut(events) {\n    _classCallCheck(this, RingOut);\n\n    this.events = events;\n\n    for (var i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n\n    this.poly = null;\n  }\n\n  _createClass(RingOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      // Remove superfluous points (ie extra points along a straight line),\n      var prevPt = this.events[0].point;\n      var points = [prevPt];\n\n      for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n        var _pt = this.events[i].point;\n        var _nextPt = this.events[i + 1].point;\n        if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n        points.push(_pt);\n        prevPt = _pt;\n      } // ring was all (within rounding error of angle calc) colinear points\n\n\n      if (points.length === 1) return null; // check if the starting point is necessary\n\n      var pt = points[0];\n      var nextPt = points[1];\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n      points.push(points[0]);\n      var step = this.isExteriorRing() ? 1 : -1;\n      var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n      var iEnd = this.isExteriorRing() ? points.length : -1;\n      var orderedPoints = [];\n\n      for (var _i = iStart; _i != iEnd; _i += step) {\n        orderedPoints.push([points[_i].x, points[_i].y]);\n      }\n\n      return orderedPoints;\n    }\n  }, {\n    key: \"isExteriorRing\",\n    value: function isExteriorRing() {\n      if (this._isExteriorRing === undefined) {\n        var enclosing = this.enclosingRing();\n        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n      }\n\n      return this._isExteriorRing;\n    }\n  }, {\n    key: \"enclosingRing\",\n    value: function enclosingRing() {\n      if (this._enclosingRing === undefined) {\n        this._enclosingRing = this._calcEnclosingRing();\n      }\n\n      return this._enclosingRing;\n    }\n    /* Returns the ring that encloses this one, if any */\n\n  }, {\n    key: \"_calcEnclosingRing\",\n    value: function _calcEnclosingRing() {\n      // start with the ealier sweep line event so that the prevSeg\n      // chain doesn't lead us inside of a loop of ours\n      var leftMostEvt = this.events[0];\n\n      for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n        var evt = this.events[i];\n        if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n      }\n\n      var prevSeg = leftMostEvt.segment.prevInResult();\n      var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n      while (true) {\n        // no segment found, thus no ring can enclose us\n        if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n        // segment must loop back around and enclose us\n\n        if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n        // segment must either loop around us or the ring of the prev prev\n        // seg, which would make us and the ring of the prev peers\n\n        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n          if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n            return prevSeg.ringOut;\n          } else return prevSeg.ringOut.enclosingRing();\n        } // two segments are from the same ring, so this was a penisula\n        // of that ring. iterate downward, keep searching\n\n\n        prevSeg = prevPrevSeg.prevInResult();\n        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n      }\n    }\n  }]);\n\n  return RingOut;\n}();\nvar PolyOut = /*#__PURE__*/function () {\n  function PolyOut(exteriorRing) {\n    _classCallCheck(this, PolyOut);\n\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n\n  _createClass(PolyOut, [{\n    key: \"addInterior\",\n    value: function addInterior(ring) {\n      this.interiorRings.push(ring);\n      ring.poly = this;\n    }\n  }, {\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n      if (geom[0] === null) return null;\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n        if (ringGeom === null) continue;\n        geom.push(ringGeom);\n      }\n\n      return geom;\n    }\n  }]);\n\n  return PolyOut;\n}();\nvar MultiPolyOut = /*#__PURE__*/function () {\n  function MultiPolyOut(rings) {\n    _classCallCheck(this, MultiPolyOut);\n\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n\n  _createClass(MultiPolyOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (polyGeom === null) continue;\n        geom.push(polyGeom);\n      }\n\n      return geom;\n    }\n  }, {\n    key: \"_composePolys\",\n    value: function _composePolys(rings) {\n      var polys = [];\n\n      for (var i = 0, iMax = rings.length; i < iMax; i++) {\n        var ring = rings[i];\n        if (ring.poly) continue;\n        if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n          var enclosingRing = ring.enclosingRing();\n          if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n          enclosingRing.poly.addInterior(ring);\n        }\n      }\n\n      return polys;\n    }\n  }]);\n\n  return MultiPolyOut;\n}();\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nvar SweepLine = /*#__PURE__*/function () {\n  function SweepLine(queue) {\n    var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n    _classCallCheck(this, SweepLine);\n\n    this.queue = queue;\n    this.tree = new SplayTree(comparator);\n    this.segments = [];\n  }\n\n  _createClass(SweepLine, [{\n    key: \"process\",\n    value: function process(event) {\n      var segment = event.segment;\n      var newEvents = []; // if we've already been consumed by another segment,\n      // clean up our body parts and get out\n\n      if (event.consumedBy) {\n        if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n        return newEvents;\n      }\n\n      var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n      if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n      var prevNode = node;\n      var nextNode = node;\n      var prevSeg = undefined;\n      var nextSeg = undefined; // skip consumed segments still in tree\n\n      while (prevSeg === undefined) {\n        prevNode = this.tree.prev(prevNode);\n        if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n      } // skip consumed segments still in tree\n\n\n      while (nextSeg === undefined) {\n        nextNode = this.tree.next(nextNode);\n        if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n      }\n\n      if (event.isLeft) {\n        // Check for intersections against the previous segment in the sweep line\n        var prevMySplitter = null;\n\n        if (prevSeg) {\n          var prevInter = prevSeg.getIntersection(segment);\n\n          if (prevInter !== null) {\n            if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n            if (!prevSeg.isAnEndpoint(prevInter)) {\n              var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n              for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                newEvents.push(newEventsFromSplit[i]);\n              }\n            }\n          }\n        } // Check for intersections against the next segment in the sweep line\n\n\n        var nextMySplitter = null;\n\n        if (nextSeg) {\n          var nextInter = nextSeg.getIntersection(segment);\n\n          if (nextInter !== null) {\n            if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n            if (!nextSeg.isAnEndpoint(nextInter)) {\n              var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n              for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                newEvents.push(_newEventsFromSplit[_i]);\n              }\n            }\n          }\n        } // For simplicity, even if we find more than one intersection we only\n        // spilt on the 'earliest' (sweep-line style) of the intersections.\n        // The other intersection will be handled in a future process().\n\n\n        if (prevMySplitter !== null || nextMySplitter !== null) {\n          var mySplitter = null;\n          if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n            var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n            mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n          } // Rounding errors can cause changes in ordering,\n          // so remove afected segments and right sweep events before splitting\n\n          this.queue.remove(segment.rightSE);\n          newEvents.push(segment.rightSE);\n\n          var _newEventsFromSplit2 = segment.split(mySplitter);\n\n          for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n            newEvents.push(_newEventsFromSplit2[_i2]);\n          }\n        }\n\n        if (newEvents.length > 0) {\n          // We found some intersections, so re-do the current event to\n          // make sure sweep line ordering is totally consistent for later\n          // use with the segment 'prev' pointers\n          this.tree.remove(segment);\n          newEvents.push(event);\n        } else {\n          // done with left event\n          this.segments.push(segment);\n          segment.prev = prevSeg;\n        }\n      } else {\n        // event.isRight\n        // since we're about to be removed from the sweep line, check for\n        // intersections between our previous and next segments\n        if (prevSeg && nextSeg) {\n          var inter = prevSeg.getIntersection(nextSeg);\n\n          if (inter !== null) {\n            if (!prevSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n              for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                newEvents.push(_newEventsFromSplit3[_i3]);\n              }\n            }\n\n            if (!nextSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n              for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                newEvents.push(_newEventsFromSplit4[_i4]);\n              }\n            }\n          }\n        }\n\n        this.tree.remove(segment);\n      }\n\n      return newEvents;\n    }\n    /* Safely split a segment that is currently in the datastructures\n     * IE - a segment other than the one that is currently being processed. */\n\n  }, {\n    key: \"_splitSafely\",\n    value: function _splitSafely(seg, pt) {\n      // Rounding errors can cause changes in ordering,\n      // so remove afected segments and right sweep events before splitting\n      // removeNode() doesn't work, so have re-find the seg\n      // https://github.com/w8r/splay-tree/pull/5\n      this.tree.remove(seg);\n      var rightSE = seg.rightSE;\n      this.queue.remove(rightSE);\n      var newEvents = seg.split(pt);\n      newEvents.push(rightSE); // splitting can trigger consumption\n\n      if (seg.consumedBy === undefined) this.tree.insert(seg);\n      return newEvents;\n    }\n  }]);\n\n  return SweepLine;\n}();\n\nvar POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nvar POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nvar Operation = /*#__PURE__*/function () {\n  function Operation() {\n    _classCallCheck(this, Operation);\n  }\n\n  _createClass(Operation, [{\n    key: \"run\",\n    value: function run(type, geom, moreGeoms) {\n      operation.type = type;\n      rounder.reset();\n      /* Convert inputs to MultiPoly objects */\n\n      var multipolys = [new MultiPolyIn(geom, true)];\n\n      for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n        multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n      }\n\n      operation.numMultiPolys = multipolys.length;\n      /* BBox optimization for difference operation\n       * If the bbox of a multipolygon that's part of the clipping doesn't\n       * intersect the bbox of the subject at all, we can just drop that\n       * multiploygon. */\n\n      if (operation.type === 'difference') {\n        // in place removal\n        var subject = multipolys[0];\n        var _i = 1;\n\n        while (_i < multipolys.length) {\n          if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n        }\n      }\n      /* BBox optimization for intersection operation\n       * If we can find any pair of multipolygons whose bbox does not overlap,\n       * then the result will be empty. */\n\n\n      if (operation.type === 'intersection') {\n        // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n        //       it could be optimized to O(n * ln(n))\n        for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n          var mpA = multipolys[_i2];\n\n          for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n            if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n          }\n        }\n      }\n      /* Put segment endpoints in a priority queue */\n\n\n      var queue = new SplayTree(SweepEvent.compare);\n\n      for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n        var sweepEvents = multipolys[_i3].getSweepEvents();\n\n        for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n          queue.insert(sweepEvents[_j]);\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n          }\n        }\n      }\n      /* Pass the sweep line over those endpoints */\n\n\n      var sweepLine = new SweepLine(queue);\n      var prevQueueSize = queue.size;\n      var node = queue.pop();\n\n      while (node) {\n        var evt = node.key;\n\n        if (queue.size === prevQueueSize) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          var seg = evt.segment;\n          throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n        }\n\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n        }\n\n        if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n        }\n\n        var newEvents = sweepLine.process(evt);\n\n        for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n          var _evt = newEvents[_i4];\n          if (_evt.consumedBy === undefined) queue.insert(_evt);\n        }\n\n        prevQueueSize = queue.size;\n        node = queue.pop();\n      } // free some memory we don't need anymore\n\n\n      rounder.reset();\n      /* Collect and compile segments we're keeping into a multipolygon */\n\n      var ringsOut = RingOut.factory(sweepLine.segments);\n      var result = new MultiPolyOut(ringsOut);\n      return result.getGeom();\n    }\n  }]);\n\n  return Operation;\n}(); // singleton available by import\n\nvar operation = new Operation();\n\nvar union = function union(geom) {\n  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n\n  return operation.run('union', geom, moreGeoms);\n};\n\nvar intersection$1 = function intersection(geom) {\n  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n\n  return operation.run('intersection', geom, moreGeoms);\n};\n\nvar xor = function xor(geom) {\n  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n\n  return operation.run('xor', geom, moreGeoms);\n};\n\nvar difference = function difference(subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n\n  return operation.run('difference', subjectGeom, clippingGeoms);\n};\n\nvar index = {\n  union: union,\n  intersection: intersection$1,\n  xor: xor,\n  difference: difference\n};\n\nexport default index;\n"],"names":["__generator","thisArg","body","f","y","t","g","_","label","sent","trys","ops","next","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","call","done","value","pop","length","push","e","step","Node","key","data","left","right","DEFAULT_COMPARE","a","b","splay","i","comparator","N","l","r","cmp","insert","node","split","printRow","root","prefix","isTail","out","printNode","indent","Tree","_root","_size","_comparator","prototype","add","remove","_remove","x","findStatic","current","compare","find","contains","forEach","visitor","ctx","Q","range","low","high","fn","keys","_a","values","min","minNode","max","maxNode","at","index","d","successor","prev","predecessor","clear","toList","head","p","load","presort","size","sort","loadRecursive","mergedList","l1","l2","p1","p2","mergeLists","createList","sortedListToBST","isEmpty","Object","defineProperty","get","enumerable","configurable","toString","String","join","update","newKey","newData","merge","start","end","middle","Math","floor","list","pivot","j","tmp","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","writable","_createClass","protoProps","staticProps","isInBbox","bbox","point","ll","ur","getBboxOverlap","b1","b2","lowerX","upperX","epsilon","Number","EPSILON","undefined","pow","EPSILON_SQ","ab","PtRounder","reset","xRounder","CoordRounder","yRounder","round","tree","SplayTree","coord","prevNode","nextNode","rounder","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","v1","v2","kross","sqrt","cosineOfAngle","pShared","pBase","pAngle","vBase","vAngle","horizontalIntersection","pt","verticalIntersection","SweepEvent","isLeft","events","ptCmp","comparePoints","link","Segment","segment","aPt","bPt","other","Error","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","consumedBy","evt2","otherSE","consume","ringOut","isInResult","baseEvent","_this","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","cosine","has","_cache$get","asine","acosine","_cache$get2","bsine","bcosine","segmentId","leftSE","rightSE","rings","windings","id","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","_bCmpARight","_aCmpBRight","ay","ax","by","bx","newRightSE","y1","y2","isAnEndpoint","lPt","rPt","vector","yDist","xFromYDist","xDist","yFromXDist","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","pt1","pt2","ve","d1","d2","intersection","newEvents","alreadyLinked","newLeftSE","oldRightSE","replaceRightSE","newSeg","slice","swapEvents","tmpEvt","consumer","consumee","_tmp","ring","winding","indexOf","_prevInResult","prevInResult","_beforeState","seg","afterState","multiPolys","_afterState","beforeState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","_i","_iMax","_ring","poly","isExterior","_index","splice","_i2","_iMax2","mp","multiPoly","_isInResult","mpsBefore","operation","type","noBefores","noAfters","least","most","numMultiPolys","diff","abs","isJustSubject","mps","isSubject","concat","leftPt","rightPt","cmpPts","RingIn","geomRing","Array","isArray","segments","firstPoint","prevPoint","fromRing","sweepEvents","PolyIn","geomPoly","exteriorRing","interiorRings","getSweepEvents","ringSweepEvents","jMax","MultiPolyIn","geom","ex","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","getAvailableLinkedEvents","firstPt","lastPt","indexLE","getLeftmostComparator","intersectionLE","ringEvents","unshift","reverse","prevPt","points","_pt","_nextPt","nextPt","shift","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","getGeom","ringGeom","MultiPolyOut","_composePolys","polyGeom","addInterior","SweepLine","queue","arguments","nextSeg","prevMySplitter","prevInter","getIntersection","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","_newEventsFromSplit","mySplitter","_newEventsFromSplit2","inter","_newEventsFromSplit3","_i3","_iMax3","_newEventsFromSplit4","_i4","_iMax4","POLYGON_CLIPPING_MAX_QUEUE_SIZE","process","env","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","Operation","moreGeoms","multipolys","subject","mpA","_j","_jMax","sweepLine","prevQueueSize","_evt","factory"],"mappings":"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","x_google_ignoreList":[0,1]}